---
layout: post
title: python3摘记
category: python
tags: [python]
description: python3以运行代码形式记录笔记
---


```


# -*- coding:utf8 -*-
# python3中默认字符集就是utf8，无需增加如上面一行的说明
#! /usr/bin/env python

############################################################
############    第一章：基础数据类型     ###################
############################################################

# （1） 3个单引号一般用于表示多行字符串、或者大段的注释
# （2） 3个双引号一般用于函数或者类的说明信息，通过__doc__访问
# （3） 查看版本信息  python -V
#  (4)  查看对象的属性，使用dir(对象)
# dir返回对象的属性列表，包括函数
dir(str)
# 不带参数时返回内置属性列表
dir()
# 单一下划线可用于不关心迭代数据项
for _ in range(5):
    print("hello")


############    1.1：数学运算     ###################
1 + 2  # >3
1 - 2  # -1
2 * -3  # >-6
2 / -3  # > -0.6666666666666666
5 // 3  # >1  舍弃小数部分取整
-5 % 3  # > 1 商是-2,余数是1
5 % 3  # > 2
5**-2  # > 0.04 ，求5的-2次方幂
abs(-1.9)  # > 1.9取绝对值
# divmod返回元组((x-x%y)/y,x%y)
divmod(-5, 3)  # > (-2,1)
pow(5, -2)  # >0.04等价于5**-2
# pow(x,y,z)类似(x**y)%z,当有第3个参数时，第2个不能取负数
pow(5, 2, 2)  # > 1
round(-1.6)  # > 结果四舍五入 -2
bin(-10)  # > 结果是字符串类型'-0b1010'
type(hex(-10))  # 结果是字符串 <class 'str'>
int(-1.9)  # >截取整数部分 -1
int('12', 11)  # > 13 表示进制是11的整数12转成10进制后的结果
import math
math.floor(1.6)  # > 1 取底
math.ceil(1.1)  # > 2 取顶

z = -1.5 + 2.1j
z.real, z.imag  # （-1.5,2.1）复数

############    1.2：逻辑运算     ###################
5 and 6  # > 6
5 or 6  # > 5
not 6  # > False
0 or 1  # > 1
1 == True  # > True
0 == False  # >True
2 == True  # > False 注意2不等价于True
2 == False  # > False，注意非1正整数做if判断时当做True



# 表示较长字符串的两种方法
longstr = u'这一段没结束' + \
    u'接着来一段'
anotherstr = ("xxx"
              "bbbb")

chr(64)  # > @ 返回整数对应的Unicode字符
ord('A')  # > 65返回Unicode字符对应的整数

s = "he ate camel food"
s[::-2]  # >'do ea t h',注意反方向跳

'abc'.capitalize()  # > 'Abc'
# 固定序列可使用in，+=，*=等操作
str1='abcdefg'
str1.center(3)  # > 'abcdefg'
str1.center(10, '*')  # > '*abcdefg**'
str1.count('d')  # >  1
str1.encode('utf8')  # >得到二进制 b'abcdefg'
str1.endswith('g')  # > True
str1.startswith('a')  # >True 判断是否以指定字符开头
# str1.expandtabs(size) 返回str1的一个副本，将制表符换成8个或者size个空格
str1.find('b', 3, 6)  # > -1 返回从第3到第6个字符之间出现b的最左边的索引值，如果没有则返回-1
# str1.index('b',3,6) #> 出现ValueError错误，功能类似find，但是找不到时报错
str1.rindex('b')  # > 1  从右向左找，返回索引值
str1.isalnum()  # > True 如果strr1非空，并且每个字符都是字母数字，则返回True
str1.isalpha()  # > True 判断字符串是否全都是字母
str1.isdigit()  # >False  判断是否全都是数字
str1.isdecimal()  # > False 判断是否都是Unicode基数为10的数字
str1.isidentifier()  # > True 判断是否每个字符都是有效的字符
str1.islower()  # > True 判断字符串中至少有一个可小写字母，并且所有字母小写
str1.isnumeric()  # > False
str1.isprintable()  # > True，有换行符时返回False
str1.isspace()  # > False 如果字符串非空，每个字符都是空白字符，则返回True，制表符也认为空白符
str1.istitle()  # > False,非空且首字母大写的字符串则返回True
str1.isupper()  # > False 类似islower，判断是否都大写
'*'.join(str1)  # > 'a*b*c*d*e*f*g' 把前面的字符插入到后面字符串的每个字符之间
str1.ljust(10, '*')  # > 'abcdefg***' 补齐到10，左对齐，右侧用'*'填充
str1.lower()  # > 'abcdefg' 把字母变小写
str1.upper()  # > 'ABCDEFG'把能大写的都变大写
str1.partition('b')  # ('a','b','cdefg')返回元组，分隔符左边，分隔符，分隔符右边
str1.partition('s')  # ('abcdefg','','')返回元组
str2 = 'abcdb123'
str2.partition('b')  # >('a','b','cdb123')
str2.rpartition('b')  # > ('abcd','b','123')
# s.replace(t,u,n) 返回s的副本，其中每个t使用u替换，最多替换n个
str2.replace('b', 'B', 3)  # > 'aBcdB123'
str2.split('b')  # >得到列表['a','cd','123']按指定字符分割，最多分n次，即最多n+1个元素
str2.splitlines()  # > 以换行符分割
str2.strip()  # > 'abcdb123' 将两头的空白字符去掉
str2.lstrip()  # > 只去掉开头的空白
str2.rstrip()  # > 只去掉结尾的空白
str2.swapcase()  # > 'ABCDB123' 大小写字母互换
str2.title()  # > 'Abcdb123'
str2.zfill(10)  # > '00abcdb123' 补齐到10，左侧用0填充

len(str2)  # > 8  返回字符串中字符的个数

str3 = reversed(str2)  # 得到的一个迭代对象<reversed object at  0x000>,使用时才能抽取到元素
''.join(reversed(str2))  # > '321bdcba' 通过join运算迭代使用反转后的各个元素
str2[::-1]  # > '321bdcba'效果与上面一样

##函数示例:从"what a <red>rose</red>"中抽取tag为red中间的数据#########


def extract_from_tag1(tag, line):
    opener = "<" + tag + ">"
    closer = "</" + tag + ">"
    try:
        i = line.index(opener)
        start = i + len(opener)
        j = line.index(closer, start)
        return line[start, j]
    except ValueError:
        return None


def extract_from_tag2(tag, line):
    opener = "<" + tag + ">"
    closer = "</" + tag + ">"
    i = line.find(opener)
    if i != -1:
        start = i + len(opener)
        j = line.find(closer, start)
        if j != -1:
            return line[start:j]
    return None

str1.count('m', 6) == str1[6:].count('m')  # > True，两者等价

# 提取路径与当前文件
spath = "/usr/local/bin/firefox"
result = spath.rpartition('/')  # >("/usr/local/bin","/","firefox")

# mktrans与translate再查
# unicodedata模块、difflib模块、io.StringIO类、textwrap模块

'The novel {0} was published in {1}'.format("Hard Times", 1854)
# 将字符串与数字拼接的话会有报错，使用format可解决该问题
"{0}{1}".format("The amount is $", 200)
"{who} turned {age} this year".format(who='she', age=88)
# 同时使用位置参数和关键字参数时，关键字参数一定在位置参数后面
"The {who} was {0} last week!".format(12, who='boy')
# 也可使用索引
stock = ["paper", "envelops", "pens"]
"we have {0[1]} in stock".format(stock)
# 字典
d = dict(animal='elephant', weight=2000)
"the {0[animal]} weights {0[weight]}kg".format(d)
"the {animal} weights {weight}kg".format(**d)

# r,a强制表象形式，但是a仅限于ASCII字符  s强制字符串形式
import decimal
print("{0} {0!s} {0!r} {0!a}".format(decimal.Decimal("93.4")))
# 93.4  93.4 Decimal('93.4') Decimal('93.4')

# 字符串格式规约
s = "The sword of truth"
"{0:->25}".format(s)  # > '-------The sword of truth'右对齐，左侧用-补齐
"{0:.<25}".format(s)  # > 'The sword of truth.......'左对齐，右侧用.补齐
"{0:.10}".format(s)  # >'The sword' 最多保留10个字符
maxwidth = 12
"{0}".format(s[:maxwidth])
"{0:.{1}}".format(s, maxwidth)
# 整数格式规约
"{0:0>12}".format(-123)  # > '00000000-123' 宽度12位包括符号位
"{0:*<+12}".format(-123)  # > '-123********' 第一个是填充字符
"{0:*^+12}".format(-123)  # > '****-123****'  第二个是对齐，< > ^ =其中=表示在符号与值之间插入
"{0:*>+12}".format(-123)  # > '********-123'  第三个是+表示必须输出符号，是-表示只负数时输出符号
"{0:*=+12}".format(-123)  # > '-********123'
"{0:b} {0:o} {0:x} {0:X}".format(164)  # > '10100100 244 a4 A4'
"{0:#b} {0:#o} {0:#x} {0:#X}".format(164)  # > '0b10100100 0o244 0xa4 0XA4'

# 内置序列类型bytearray、bytes、list、str、tuple
# 序列类型可用*= ,in ,len() ,分片[] 操作

# 元组只有两个方法count与index
t1 = tuple("abca")  # > t1即 ('a','b','c','a')
t1.count('a')  # > 2
t1.index('a')  # > 0
hair = "a", "b", "c", "d"
hair[:2], 'gray', hair[2:]  # 得到元组(("a","b"),"gray",("c","d"))，元组的分片得到元组
# hair[:2]+"gray"+hair[2:] 这种写法是错误的，元组与字符串不能用+连接
hair[:2] + ("gray",) + hair[2:]  # >得到元组 ('a','b','gray','c','d')
# 元组只有一个元素时，最后的逗号不能省略
type((1))  # > 返回的是int
type((1,))  # > 返回的是tuple

# 命名元组collections.namedtuple()
import collections
# 第一个参数Sale是想创建的类名，第二个参数是空格隔开的字段名称
Sale = collections.namedtuple(
    "Sale", "productid customerid date quantity price")
sale1 = Sale(432, 921, "2008-09-14", 3, 7.99)
sale1.price  # > 7.99 命名元组可用 .字段名取值

# 列表使用[]创建
list1 = list("abc321")  # > 得到列表['a','b','c','3','2','1']
list1.append('x')  # > ['a','b','c','3','2','1','x']在最后追加一个元素
list1.count('a')  # > 1 统计元素出现次数
# list1.extend(m)  #>将迭代器m的项追加到list1的最后，类似 +=
list1.index('b', 0, 3)  # > 1 返回b在索引位置0到3之间最左边出现b的位置，如果没有则报错
list1.insert(3, 'd')  # > ['a','b','c','d','3','2','1','x']在索引位3的位置插入'd'

list1.pop()  # >返回并删除最右边的项，list1变成['a','b','c','d','3','2','1']
list1.pop(2)  # > ['a','b','d','3','2','1'] 删除指定索引位置的元素
list1.remove('a')  # >  ['b','d','3','2','1'] 删除最左边出现的指定元素
list1.reverse()  # > list1变成 ['1','2','3','d','b']
first, *rest = list1  # > rest为列表['2','3','d','b']
del rest[1]  # >删除rest中的索引值为1 的项

# 列表迭代器创建列表
leaps = []
for year in range(1900, 1940):
    if(year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
        leaps.append(year)
# [item运算表达式   for item in 迭代器 if condition]
list2 = [a + b for a in ['a', 'b', 'c'] for b in ['x', 'y', 'z']]
# list2被创建为['ax','ay','az','bx','by','bz','cx','cy','cz']

# 可变集合set类型，固定集合frozenset类型
# 集合中的元素不能使用dict、list、set类型，只能使用可hash的类型，内置的有float、frozenset、int、str、tuple
# 集合中的元素没有索引值的概念，是无序的，没有重复的元素
# 集合可用于爬虫时做唯一值判断，避免重复爬取
s1 = set()  # 创建空集合，使用s1={}创建的是字典
s1 = set("apple")  # >得到集合{'a','p','l','e'}
s1.add('b')  # > 追加元素
s1.clear()  # > 清空元素
s1.copy()  # > 返回s1的一个浅拷贝，用is判断得False，用==判断得True
s1 = set("apple")
s1.pop()  # > 随机删除s1中一个元素，为空集时报错
s2 = {'a'}
s1.difference(s2)  # > 在s1中，但是不在s2中的，等价s1-s2,s1和s2没被改变
s1.difference_update(s2)  # > s1被改变，删除其中s2中的元素，等价于s1-=s2
s1.discard('a')  # >删除元素，不存在时不报错
s1.add('a')
s1.remove('a')  # >删除元素，不存在的元素时报错
s1.intersection(s2)  # >返回s1与s2的交集，等价于s1&s2
s1.intersection_update(s2)  # >求交集并赋值给s1，等价于s1&=s2
s1.isdisjoint(s2)  # >如果s1与s2没交集，则返回True
s1.issubset(s2)  # > s1如果是s2的子集，则返回True
s1.issuperset(s2)  # > s1如果是s2的超集，则返回True
s1.symmetric_difference(s2)  # >返回一个新集合，并集减去交集的结果，等价s1^s2
s1.symmetric_difference_update(s2)  # 等价于s1^=s2
s1.union(s2)  # > 返回一个新集合，返回s1与s2的并集，等价于s1|s2
s1.update(s2)  # > 等价于s1|=s2
# 处理不重复项示例
seen = set()
for i in range(10):
    if i not in seen:
        seen.add(i)
        # process(i)
ips=["192.168.0.1"]
for ip in set(ips):
    pass
#集合生成器
files=["index.html","t.css"]
html = { x for x in files if x.lower().endswith((".htm",".html"))}

#固定集合frozenset，上面集合中不影响集合自身的方法都适用于固定集合
#固定集合与普通集合做二元运算时，结果以左侧为准
s3 = frozenset("123") #> {'3','2','1'}


#字典dict包含0个或者多个key-value对，key必须是可hash运算的，字典无序
d1 = dict({"id":1948,"name":"Washer","size":3})
d2 = dict(id=1948,name="Washer",size=3)
d3 = dict([("id",1948),("name","Washer"),("size",3)])
d4 = dict(zip(("id","name","size"),(1948,"Washer",3)))
d5 = {"id":1948,"name":"Washer","size":3}

d1==d2==d3==d4==d5 #> True 上面五种创建字典的结果是一样的
d1.clear() #>移除d1中所有项
d1.copy() #> 返回d1的浅拷贝
s=["id","name"]
newv=[123,'test']
d2.fromkeys(s) #> 得到字典{"id":None,"name":None}
d2.fromkeys(s,newv) #> {"id":[123,'test'],"name":[123,'test']}
d2.get("id") #> 1948 ，根据key查找value
d2.get("score",100) #> 100，查找key,如果不存在，则返回默认值，字典本身没变
d2.items() #>返回所有(key,value)组成的视图，可迭代查询，不能更改
d2.keys() #返回所有key组成的视图，可迭代查询，不能更改
d2.values() #返回所有value组成的视图，可迭代查询，不能更改
d2.pop("id") #从d2中删除key为id的项，并将对应的value返回，如果key不存在，则报错
d2.pop("id",10) #从d2中删除key为id的项，如果不存在，返回默认值10
d2.popitem() #>返回值是被随机删除的一个key,value组成的字典,d2被改变
d2.setdefault("id",11) #>如果d2中有key为id则返回其value，如果没有，则添加key为id的项
#d2.update(a)  #>将a更新到d2中，a可以是字典，也可以是(key,value)迭代

d = {}.fromkeys("ABC",3) #>{"A":3,"B":3,"C":3} 实际字典是无序的
s = set("ACX")
matches = d.keys() & s #> {"A","C"} 视图与集合之间支持交集
matches = d.keys() | s #> {"A","C","X","B"} 支持并集
matches = d.keys() - s #> {"B"} 支持差集
matches = d.keys() ^ s #> {"X","B"} 返回并集减去交集的结果

#################################################
####用于统计文件中各个单词出现次数的示例
#################################################
import string
import sys
import os

words={}
strip = string.whitespace + string.punctuation + string.digits + "\""
for filename in sys.argv[1:]:
    for line in open(filename,encoding='utf8'):
        for word in line.lower().split():
            word = word.strip(strip)
            if len(word)>2:
                words[word] = words.get(word,0)+1
for word in sorted(words):
    print("'{0}' occurs {1} times".format(word,words[word]))
#################################################

#字典生成器 {key表达式：value表达式 for key,value in iterable if condition}
file_sizes={name:os.path.getsize(name) for name in os.listdir(".") if os.path.isfile(name)}
#字典生成器也可用于key与value的反转,如果失败会产品TypeError异常
inverted_d = {v:k for k,v in d2.items()}

#默认字典 defaultdict，所有方法与字典一样
import collections
words = collections.defaultdict(int)
#使用默认字典时，如果key值不存在，则自动添加该key，设置如图的Int函数的默认值
x=words["xyz"]
#另外一个创建默认值的方法，使用lambda
minus_one_dict = collections.defaultdict(lambda:-1)

#有序字典 collections.OrderedDict以数据的插入顺序进行存储
tasks = collections.OrderedDict()
tasks[8031]="aaa"
tasks[8032]="bbb"
tasks[8033]="ccc"
#使用popitem()来删除并返回最后一个键值项
#使用popitem(last=False)来删除并返回第一个键值项
tasks.popitem(last=False) #> （8031,'aaa')
#将普通字典转给有序字典
d = collections.OrderedDict(sorted(d.items()))

#任意包含__iter__()方法的对象都是迭代对象，每次返回其中一个数据项
x = [-2,9,7,-4,3]
all(x),any(x),len(x),min(x),max(x),sum(x) #> (True,True,5,-4,9,13)
x.append(0)
all(x),any(x),len(x),min(x),max(x),sum(x) #> (False,True,6,-4,9,13)

#实现一个类似于grep命令的脚本，第一个参数是关键字，后面是文件名
# if len(sys.argv)<3:
#     print("usage: {0} word infiles [infile2 [...infileN]]".format(sys.argv[0]))
#     sys.exit()
# word = sys.argv(1)
# for filename in sys.argv[2:]:
#     for lino,line in enumerate(open(filename),start=1):
#         if word in line:
#             print("{0}:{1}:{2:.40}".format(filename,lino,line.rstrip()))

for a,b in zip((1,2,3,),('a','b','c')):
    print(a,b)
#>(1,a),(2,b)
for t in zip(range(4),range(0,10,2),range(1,10,2)):
    print(t)  #>迭代每次前进一个，range(4)最多产生4个，所以结果最多4个值
#>(0,0,1)
#>(1,2,3)
#>(2,4,5)
#>(3,6,7)

#python排序算法sorted()函数，可通过key指定排序函数，例如abs
#sorted只能用于所有元素是可比较的

#变量只是对象的的一个引用，如果同时指向同一个对象的两个变量，其中一个改变，另外一个也改变
a=[1,2,3]
b=a
a[1]=4
print(b[1])  #>结果是4
#列表可使用 b = a[:]的方式创建一个新的对象来实现复制
#字典可使用copy函数
#浅拷贝，元素的元素随着新值改变
x=[53,["B","D"]]
y=x[:]
x[0]=40
x[1][1]="Changed"
print(x,y)  #> [40, ['B', 'Changed']] [53, ['B', 'Changed']]
#深拷贝，元素的元素不能改变
import copy 
x1 = [53,["B","D"]]
y1 = copy.deepcopy(x1)
y1[0]=40
y1[1][1]="Changed"
print(x1,y1)  #> [53, ['B', 'D']] [40, ['B', 'Changed']]

offset = 20
if not sys.platform.startswith("win"):
    offset = 10

offset = 20 if sys.platform.startswith("win") else 10
margin = 10
width = 100 + 10 if margin else 0 #容易造成误解，margin为False时，width为0
width = 100 + (10 if margin else 0)
count = 4
print("{0} file{1}".format((count if count !=0 else "no"),("s" if count != 1 else "")))

#while循环
def list_find1(lst,target):
    index = 0
    while index < len(lst):
        if lst[index] == target:
            break
        index +=1
    else:
        index = -1
    return index
#for循环示例
def list_find2(lst,target):
    for index,x in enumerate(lst):
        if x == target:
            break
    else:
        index = -1
    return index

#捕捉异常的语法示例
def read_data(filename):
    lines = []
    fh = None
    try:
        fh = open(filename,encoding='utf8')
        for line in fh:
            if line.strip():
                lines.append(line)
    except (IOError,OSError) as err:
        print(err)
        return []
    finally:
        if fh is not None:
            fh.close()
    return lines

#统计字符串中字母的个数
#对函数添加说明信息，即在def语句下面使用三个双引号
def letter_count(text,letters=string.ascii_letters):
    """
    count the letters in the text
    """
    letters = frozenset(letters)
    count = 0
    for char in text:
        if char in letters:
            count += 1
    return count
#letter_count("ABC")
print(letter_count.__doc__)
##函数的参数，带默认值的必须放在最后，没有默认值的必须在调用时传参
#函数的参数不能使用可变的数据类型，例如列表

#函数参数类型：
#---------位置参数
#---------默认参数  
#---------可变个数参数 *args，在函数中使用args，类似一个元组
#---------关键字参数 **kwargs  在函数中使用kwarg["key"]
#---------命名关键字参数，使用一个*分割，后面的参数必须都是有默认值

#可变个数的参数，使用*引导
def sum_of_powers(*args,power=1):
    result = 0 
    for arg in args:
        result += arg**power
    print(result)
sum_of_powers(1,3,5) #> 9
sum_of_powers(1,1,3,4,power=2) #> 27

#常量
Language = "en"
ENGILISH = {0:'zero',1:'one',2:'two'}
CHINESE = {0:'零',1:'一',2:'二'}
def print_digits(digits):
    dictionary = ENGILISH if Language == "en" else CHINESE
    for digit in digits:
        print(dictionary[int(digit)],end='')
    print()
print_digits("212")  #> twoonetwo

#lambda函数  lambda [arg1[,arg2,arg3...]]:expression

########第五章 模块##################
#任意一个py文件都是一个模块，模块的设计目的是由其他程序导入并使用
#模块查找的位置是通过sys.path中的路径查找的，即PYTHONPATH
#包 就是一堆模块，加一个__init__.py文件，在该init文件中可通过定义__all__属性指定可访问的模块

#标准库 string
print(string.ascii_letters) #>英文字母
print(string.hexdigits)  #>十六进制

# optparse模块，用于命令行选项处理
import optparse
def main():
    parser = optparse.OptionParser()
    parser.add_option("-w","--maxwidth",dest="maxwidth",type="int",help="maxwidth")
    parser.set_defaults(maxwidth=5)
    opts,args = parser.parse_args()

########第六章 面向对象程序设计#########
####继承  多态  封装 ###################
class Point():
    def __init__(self,x=0,y=0):
        self.x = x 
        self.y = y 
    def distance_from_origin(self):
        return math.hypot(self.x,self.y)
    def __eq__(self,other):
        return self.x == other.x and self.y == other.y 
    def __repr__(self):
        return "Point({0.x!r},{0.y!r}".format(self) #> !r 强制表象形式
    def __str__(self):
        return "({0.x!r},{0.y!r})".format(self)
#创建对象的过程是先调用__new__()方法，再使用__init__()方法
#对象默认支持==运算，通过修改__eq__()方法可修改该运算结果，不修改的话，可有hash()运算
p1=Point(3,4)
p2=Point(3,4)
print(p1==p2)  #> True
# pd = {p1:1,p2:2} 此时会报错，因为__eq__()方法修改后，hash()不存在了
#检查对象是否是类的实例  isinstance(other,Point)
class Circle(Point):
    def __init__(self,radius,x=0,y=0):
        super().__init__(x,y)             # 调用父类的初始化函数
        self.radius = radius
    @property
    def edge_distance_from_origin(self):
        return abs(self.distance_from_origin()-self.radius)
    @property
    def area(self):
        return math.pi*(self.radius**2)
    def circumference(self):
        return 2*math.pi*self.radius
    def __eq__(self,other):
        return self.radius==other.radius and super().__eq__(other)
    def __repr__(self):
        return "Circle({0.radius!r},{0.x!r},{0.y!r})".format(self)
    def __str__(self):
        return repr(self)
#在类方法上面添加@property，使其像属性一样被调用
c1=Circle(5)
print(c1.area)
#对属性的封装 getter setter  deleter
class NewCircle(Point):
    def __init__(self,x=0,y=0):
        super().__init__(x,y)             # 调用父类的初始化函数
    @property
    def radius(self):
        ''' The Circle radius'''
        return self.__radius
    @radius.setter
    def radius(self,radius):
        assert radius>0,"raduis must be nonezero and non-negative"
        self.__radius=radius
    @property
    def edge_distance_from_origin(self):
        return abs(self.distance_from_origin()-self.radius)
    @property
    def area(self):
        return math.pi*(self.radius**2)
    def circumference(self):
        return 2*math.pi*self.radius
    def __eq__(self,other):
        return self.radius==other.radius and super().__eq__(other)
    def __repr__(self):
        return "Circle({0.radius!r},{0.x!r},{0.y!r})".format(self)
    def __str__(self):
        return repr(self)
c2 = NewCircle()
c2.radius = 10
#c2.radius = -4 会报错，因为前面的setter中添加了限制

#从头开始创建一个完整的数据类型，多数情况下，这种方案更常见
class FuzzyBool:   #继承自object的可以不写object
    def __init__(self, value=0.0):
        """
        >>> f = FuzzyBool()
        >>> g = FuzzyBool(.5)
        >>> h = FuzzyBool(3.75)
        >>> f, g, h
        (FuzzyBool(0.0), FuzzyBool(0.5), FuzzyBool(0.0))
        """
        #取值不在范围中时，强制归置为 0.0
        self.__value = value if 0.0 <= value <= 1.0 else 0.0
    def __invert__(self):  #逻辑非，~，取反转值
        """Returns the logical not of this FuzzyBool

        >>> f = FuzzyBool(0.125)
        >>> ~f
        FuzzyBool(0.875)
        >>> ~FuzzyBool()
        FuzzyBool(1.0)
        >>> ~FuzzyBool(1)
        FuzzyBool(0.0)
        """
        return FuzzyBool(1.0 - self.__value)
    #删除对象的__del__()方法不建议重新实现，只有引用计数为0时才调用，但不一定调用
    def __and__(self, other):   #对应  & 运算
        """Returns the logical and of this FuzzyBool and the other one

        >>> FuzzyBool(0.5) & FuzzyBool(0.6)
        FuzzyBool(0.5)
        """
        return FuzzyBool(min(self.__value, other.__value))
    def __iand__(self, other):  #对应  &= 运算
        """Applies logical and to this FuzzyBool with the other one

        >>> f = FuzzyBool(0.5)
        >>> f &= FuzzyBool(0.6)
        >>> f
        FuzzyBool(0.5)
        """
        self.__value = min(self.__value, other.__value)
        return self

    @staticmethod
    def conjunction(*fuzzies):
        """Returns the logical and of all the FuzzyBools

        >>> FuzzyBool.conjunction(FuzzyBool(0.5), FuzzyBool(0.6), 0.2, 0.125)
        FuzzyBool(0.125)
        """
        return FuzzyBool(min([float(x) for x in fuzzies]))
    def __or__(self, other):
        """Returns the logical or of this FuzzyBool and the other one

        >>> FuzzyBool(0.5) | FuzzyBool(0.75)
        FuzzyBool(0.75)
        """
        return FuzzyBool(max(self.__value, other.__value))
    def __ior__(self, other):
        """Applies logical or to this FuzzyBool with the other one

        >>> f = FuzzyBool(0.5)
        >>> f |= FuzzyBool(0.75)
        >>> f
        FuzzyBool(0.75)
        """
        self.__value = max(self.__value, other.__value)
        return self
    @staticmethod
    def disjunction(*fuzzies):  #传递一个可变数量的参数
        """Returns the logical or of all the FuzzyBools

        >>> FuzzyBool.disjunction(FuzzyBool(0.5), FuzzyBool(0.75), 0.2, 0.1)
        FuzzyBool(0.75)
        """
        return FuzzyBool(max([float(x) for x in fuzzies]))
    def __repr__(self):  #注释使用   self.__class__.__name__
        """
        >>> f = FuzzyBool(0.5)
        >>> repr(f)
        'FuzzyBool(0.5)'
        """
        return ("{0}({1})".format(self.__class__.__name__,self.__value))
    def __str__(self):
        """
        >>> f = FuzzyBool(0.5)
        >>> str(f)
        '0.5'
        """
        return str(self.__value)
    def __bool__(self):  #使用0.5的边界做判断
        """
        >>> f = FuzzyBool(.3)
        >>> g = FuzzyBool(.51)
        >>> bool(f), bool(g)
        (False, True)
        """
        return self.__value > 0.5
    def __int__(self):
        return round(self.__value)
    def __float__(self):
        return self.__value
    def __lt__(self, other):
        return self.__value < other.__value
    def __eq__(self, other):
        return self.__value == other.__value
    def __hash__(self):
        return hash(id(self))
    def __format__(self, format_spec):
        """
        >>> f = FuzzyBool(.875)
        >>> "{0:.0%}".format(f)
        '88%'
        >>> "{0:.1%}".format(f)
        '87.5%'
        """
        return format(self.__value, format_spec)

help(FuzzyBool.__invert__)  #用于查看函数的docstring

#继承自float数据类型来创建FuzzyBool数据类型
#注意这里重写了__new__()方法，另外conjunction和djsjunction放到类定义外面
def conjunction(*fuzzies):
    """Returns the logical and of all the FuzzyBools

    >>> conjunction(FuzzyBool(0.5), FuzzyBool(0.6), 0.2, 0.125)
    FuzzyBool(0.125)
    """
    return FuzzyBoolNew(min(fuzzies))
def disjunction(*fuzzies):
    """Returns the logical or of all the FuzzyBools

    >>> disjunction(FuzzyBool(0.5), FuzzyBool(0.75), 0.2, 0.1)
    FuzzyBool(0.75)
    """
    return FuzzyBoolNew(max(fuzzies))

#类方法：使用装饰器 @classmethod，第一个参数一般是self
#静态方法: 使用装饰器 @staticmethod ，不需要第一个实例参数self

class FuzzyBoolNew(float):     #注意括号中是float
    def __new__(cls, value=0.0):    #注意cls，不是self，此时还没有self实例
        """
        >>> f = FuzzyBool()
        >>> g = FuzzyBool(.5)
        >>> h = FuzzyBool(3.75)
        >>> f, g, h
        (FuzzyBool(0.0), FuzzyBool(0.5), FuzzyBool(0.0))
        """
        return super().__new__(cls,value if 0.0 <= value <= 1.0 else 0.0)
    def __invert__(self):
        """Returns the logical not of this FuzzyBool

        >>> f = FuzzyBool(0.125)
        >>> ~f
        FuzzyBool(0.875)
        >>> ~FuzzyBool()
        FuzzyBool(1.0)
        >>> ~FuzzyBool(1)
        FuzzyBool(0.0)
        """
        return FuzzyBool(1.0 - float(self))
    def __and__(self, other):
        """Returns the logical and of this FuzzyBool and the other one

        >>> FuzzyBool(0.5) & FuzzyBool(0.6)
        FuzzyBool(0.5)
        """
        return FuzzyBool(min(self, other))
    def __iand__(self, other):
        """Applies logical and to this FuzzyBool with the other one

        >>> f = FuzzyBool(0.5)
        >>> f &= FuzzyBool(0.6)
        >>> f
        FuzzyBool(0.5)
        """
        return FuzzyBool(min(self, other))
    def __or__(self, other):
        """Returns the logical or of this FuzzyBool and the other one

        >>> FuzzyBool(0.5) | FuzzyBool(0.75)
        FuzzyBool(0.75)
        """
        return FuzzyBool(max(self, other))
    def __ior__(self, other):
        """Applies logical or to this FuzzyBool with the other one

        >>> f = FuzzyBool(0.5)
        >>> f |= FuzzyBool(0.75)
        >>> f
        FuzzyBool(0.75)
        """
        return FuzzyBool(max(self, other))
    def __repr__(self):
        """
        >>> f = FuzzyBool(0.5)
        >>> repr(f)
        'FuzzyBool(0.5)'
        """
        return ("{0}({1})".format(self.__class__.__name__,super().__repr__()))
    def __bool__(self):
        """
        >>> f = FuzzyBool(.3)
        >>> g = FuzzyBool(.51)
        >>> bool(f), bool(g)
        (False, True)
        """
        return self > 0.5
    def __int__(self):
        """
        >>> f = FuzzyBool(.3)
        >>> g = FuzzyBool(.51)
        >>> int(f), int(g)
        (0, 1)
        """
        return round(self)  #四舍五入

    for name, operator in (("__neg__", "-"),("__index__", "index()")):
        message = ("bad operand type for unary {0}: '{{self}}'".format(operator))
        exec("def {0}(self): raise TypeError(\"{1}\".format(""self=self.__class__.__name__))".format(name, message))

    for name, operator in (("__xor__", "^"), ("__ixor__", "^="),
            ("__add__", "+"), ("__iadd__", "+="), ("__radd__", "+"),
            ("__sub__", "-"), ("__isub__", "-="), ("__rsub__", "-"),
            ("__mul__", "*"), ("__imul__", "*="), ("__rmul__", "*"),
            ("__pow__", "**"), ("__ipow__", "**="),
            ("__rpow__", "**"), ("__floordiv__", "//"),
            ("__ifloordiv__", "//="), ("__rfloordiv__", "//"),
            ("__truediv__", "/"), ("__itruediv__", "/="),
            ("__rtruediv__", "/"), ("__divmod__", "divmod()"),
            ("__rdivmod__", "divmod()"), ("__mod__", "%"),
            ("__imod__", "%="), ("__rmod__", "%"),
            ("__lshift__", "<<"), ("__ilshift__", "<<="),
            ("__rlshift__", "<<"), ("__rshift__", ">>"),
            ("__irshift__", ">>="), ("__rrshift__", ">>")):
        message = ("unsupported operand type(s) for {0}: "
                   "'{{self}}'{{join}} {{args}}".format(operator))
        exec("def {0}(self, *args):\n"
             "    types = [\"'\" + arg.__class__.__name__ + \"'\" "
             "for arg in args]\n"
             "    raise TypeError(\"{1}\".format("
             "self=self.__class__.__name__, "
             "join=(\" and\" if len(args) == 1 else \",\"),"
             "args=\", \".join(types)))".format(name, message))

#创建 聚集组合数据  的类，以图像类数据为例，写成模块Image.py
#模块开头使用shebang，即 #!/usr/bin/env python3 ,之后版权信息，之后是模块的docstring
#之后是使用示例doctests
#如下是拷贝的Image.py模块
#!/usr/bin/env python3
# Copyright (c) 2008-11 Qtrac Ltd. All rights reserved.

"""
This module provides the Image class which holds (x, y, color) triples
and a background color to provide a kind of sparse-array representation of
an image. A method to export the image in XPM format is also provided.
>>> import os
>>> import tempfile
>>> red = "#FF0000"
>>> blue = "#0000FF"
>>> img = os.path.join(tempfile.gettempdir(), "test.img")
>>> xpm = os.path.join(tempfile.gettempdir(), "test.xpm")
>>> image = Image(10, 8, img)
>>> for x, y in ((0, 0), (0, 7), (1, 0), (1, 1), (1, 6), (1, 7), (2, 1),
...             (2, 2), (2, 5), (2, 6), (2, 7), (3, 2), (3, 3), (3, 4),
...             (3, 5), (3, 6), (4, 3), (4, 4), (4, 5), (5, 3), (5, 4),
...             (5, 5), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (7, 1),
...             (7, 2), (7, 5), (7, 6), (7, 7), (8, 0), (8, 1), (8, 6),
...             (8, 7), (9, 0), (9, 7)):
...    image[x, y] = blue
>>> for x, y in ((3, 1), (4, 0), (4, 1), (4, 2), (5, 0), (5, 1), (5, 2),
...             (6, 1)):
...    image[(x, y)] = red
>>> print(image.width, image.height, len(image.colors), image.background)
10 8 3 #FFFFFF
>>> border_color = "#FF0000" # red
>>> square_color = "#0000FF" # blue
>>> width, height = 240, 60
>>> midx, midy = width // 2, height // 2
>>> image = Image(width, height, img, "#F0F0F0")
>>> for x in range(width):
...     for y in range(height):
...         if x < 5 or x >= width - 5 or y < 5 or y >= height -5:
...             image[x, y] = border_color
...         elif midx - 20 < x < midx + 20 and midy - 20 < y < midy + 20:
...             image[x, y] = square_color
>>> print(image.width, image.height, len(image.colors), image.background)
240 60 3 #F0F0F0
>>> image.save()
>>> newimage = Image(1, 1, img)
>>> newimage.load()
>>> print(newimage.width, newimage.height, len(newimage.colors), newimage.background)
240 60 3 #F0F0F0
>>> image.export(xpm)
>>> image.thing
Traceback (most recent call last):
...
AttributeError: 'Image' object has no attribute 'thing'
>>> for name in (img, xpm):
...     try:
...         os.remove(name)
...     except EnvironmentError:
...         pass
"""

import os
import pickle
USE_GETATTR = False
class ImageError(Exception): pass
class CoordinateError(ImageError): pass
class LoadError(ImageError): pass
class SaveError(ImageError): pass
class ExportError(ImageError): pass
class NoFilenameError(ImageError): pass

class Image:
    def __init__(self, width, height, filename="",background="#FFFFFF"):
        """An image represented as HTML-style color values
        (color names or hex strings) at (x, y) coordinates with any
        unspecified points assumed to be the background
        """
        self.filename = filename
        self.__background = background
        self.__data = {}        #字典，key是坐标，value是颜色
        self.__width = width
        self.__height = height
        self.__colors = {self.__background}

    if USE_GETATTR:
        def __getattr__(self, name):
            """
            >>> image = Image(10, 10)
            >>> len(image.colors) == 1
            True
            >>> image.width == image.height == 10
            True
            >>> image.thing
            Traceback (most recent call last):
            ...
            AttributeError: 'Image' object has no attribute 'thing'
            """
            if name == "colors":
                return set(self.__colors)
            classname = self.__class__.__name__
            if name in frozenset({"background", "width", "height"}):
                return self.__dict__["_{classname}__{name}".format(**locals())]
            raise AttributeError("'{classname}' object has no attribute '{name}'".format(**locals()))
    else:
        @property   #对私有属性的获取
        def background(self):
            return self.__background
        @property
        def width(self):
            return self.__width
        @property
        def height(self):
            return self.__height
        @property
        def colors(self):
            return set(self.__colors)

    def __getitem__(self, coordinate):
        """Returns the color at the given (x, y) coordinate; this will
        be the background color if the color has never been set
        """
        assert len(coordinate) == 2, "coordinate should be a 2-tuple"
        if (not (0 <= coordinate[0] < self.width) or
            not (0 <= coordinate[1] < self.height)):
            raise CoordinateError(str(coordinate))
        return self.__data.get(tuple(coordinate), self.__background)

    def __setitem__(self, coordinate, color):
        """Sets the color at the given (x, y), coordinate
        """
        assert len(coordinate) == 2, "coordinate should be a 2-tuple"
        if (not (0 <= coordinate[0] < self.width) or
            not (0 <= coordinate[1] < self.height)):
            raise CoordinateError(str(coordinate))
        if color == self.__background:
            self.__data.pop(tuple(coordinate), None)
        else:
            self.__data[tuple(coordinate)] = color
            self.__colors.add(color)

    def __delitem__(self, coordinate):
        """Deletes the color at the given (x, y) coordinate

        In effect this makes the coordinate's color the background color.
        """
        assert len(coordinate) == 2, "coordinate should be a 2-tuple"
        if (not (0 <= coordinate[0] < self.width) or
            not (0 <= coordinate[1] < self.height)):
            raise CoordinateError(str(coordinate))
        self.__data.pop(tuple(coordinate), None)

    def save(self, filename=None):
        """Saves the current image, or the one specified by filename

        If filename is specified the internal filename is set to it.
        """
        if filename is not None:
            self.filename = filename
        if not self.filename:
            raise NoFilenameError()
        fh = None
        try:
            data = [self.width, self.height, self.__background,self.__data]
            fh = open(self.filename, "wb")
            # pickle 将对象序列化
            pickle.dump(data, fh, pickle.HIGHEST_PROTOCOL)
        except (EnvironmentError, pickle.PicklingError) as err:
            raise SaveError(str(err))
        finally:
            if fh is not None:
                fh.close()
        
    def load(self, filename=None):
        """Loads the current image, or the one specified by filename

        If filename is specified the internal filename is set to it.
        """
        if filename is not None:
            self.filename = filename
        if not self.filename:
            raise NoFilenameError()
        fh = None
        try:
            fh = open(self.filename, "rb")
            data = pickle.load(fh)
            (self.__width, self.__height, self.__background,
             self.__data) = data
            self.__colors = (set(self.__data.values()) |
                             {self.__background})
        except (EnvironmentError, pickle.UnpicklingError) as err:
            raise LoadError(str(err))
        finally:
            if fh is not None:
                fh.close()

    def export(self, filename):
        """Exports the image to the specified filename
        """
        if filename.lower().endswith(".xpm"):
            self.__export_xpm(filename)
        else:
            raise ExportError("unsupported export format: " + os.path.splitext(filename)[1])

    def __export_xpm(self, filename):
        """Exports the image as an XPM file if less than 8930 colors are
        used
        """
        name = os.path.splitext(os.path.basename(filename))[0]
        count = len(self.__colors)
        chars = [chr(x) for x in range(32, 127) if chr(x) != '"']
        if count > len(chars):
            chars = []
            for x in range(32, 127):
                if chr(x) == '"':
                    continue
                for y in range(32, 127):
                    if chr(y) == '"':
                        continue
                    chars.append(chr(x) + chr(y))
        chars.reverse()
        if count > len(chars):
            raise ExportError("cannot export XPM: too many colors")
        fh = None
        try:
            fh = open(filename, "w", encoding="ascii")
            fh.write("/* XPM */\n")
            fh.write("static char *{0}[] = {{\n".format(name))
            fh.write("/* columns rows colors chars-per-pixel */\n")
            fh.write('"{0.width} {0.height} {1} {2}",\n'.format(
                     self, count, len(chars[0])))
            char_for_colour = {}
            for color in self.__colors:
                char = chars.pop()
                fh.write('"{char} c {color}",\n'.format(**locals()))
                char_for_colour[color] = char
            fh.write("/* pixels */\n")
            for y in range(self.height):
                row = []
                for x in range(self.width):
                    color = self.__data.get((x, y), self.__background)
                    row.append(char_for_colour[color])
                fh.write('"{0}",\n'.format("".join(row)))
            fh.write("};\n")
        except EnvironmentError as err:
            raise ExportError(str(err))
        finally:
            if fh is not None:
                fh.close()

#数据的聚集，参考 SortedList.py文件
_identity = lambda x: x
class SortedList:
    def __init__(self, sequence=None, key=None):
        self.__key = key or _identity  #用or来优先选择指定的key函数
        assert hasattr(self.__key, "__call__")  #判断key函数是可调用的函数，所有可调用函数或方法都有属性__call__
        if sequence is None:
            self.__list = []
        elif (isinstance(sequence, SortedList) and sequence.key == self.__key):
            self.__list = sequence.__list[:]
        else:
            self.__list = sorted(list(sequence), key=self.__key)
    @property
    def key(self):
        """Return the key function used by this list
        """
        return self.__key
    def clear(self):
        self.__list = []
    def __bisect_left(self, value):  #查找value对应的最左侧的索引值
        """Returns value's key and its index position in the list
        (or where value belongs if it isn't in the list)
        """
        key = self.__key(value)   #key
        left, right = 0, len(self.__list)
        while left < right:        #使用二叉搜索
            middle = (left + right) // 2
            if self.__key(self.__list[middle]) < key:
                left = middle + 1
            else:
                right = middle
        return key, left  #返回的left是value的索引位置

    def add(self, value):
        """Adds a value to the list (duplicates are allowed)
        """
        index = self.__bisect_left(value)[1]
        if index == len(self.__list):
            self.__list.append(value)
        else:
            self.__list.insert(index, value)

    def pop(self, index=-1):
        """Removes and returns the item the given index
        """
        return self.__list.pop(index)  #删除列表中指定索引值的元素

    def remove(self, value):
        """Removes the first occurrence of value from the list
        """
        key, index = self.__bisect_left(value)
        while (index < len(self.__list) and
                self.__key(self.__list[index]) == key):
            if self.__list[index] == value:
                del self.__list[index]
                return
            index += 1
        raise ValueError("{0}.remove(x): x not in list".format(
                            self.__class__.__name__))

    def remove_every(self, value):
        """Removes every occurrence of value from the list
        """
        count = 0
        key, index = self.__bisect_left(value)
        while (index < len(self.__list) and
               self.__key(self.__list[index]) == key):
            del self.__list[index]
            count += 1
        return count

    def count(self, value):
        """Counts every occurrence of value in the list
        """
        count = 0
        key, index = self.__bisect_left(value)
        while (index < len(self.__list) and
               self.__key(self.__list[index]) == key):
            index += 1
            count += 1
        return count

    def index(self, value):
        """Returns the index position of the first occurrence of value
        """
        key, index = self.__bisect_left(value)
        if (index < len(self.__list) and
            self.__key(self.__list[index]) == key):
            return index
        raise ValueError("{0}.index(x): x not in list".format(
                         self.__class__.__name__))

    def __delitem__(self, index):
        """Deletes the value at the given index position
        """
        del self.__list[index]
        
    def __getitem__(self, index):
        """Returns the value at the given index position
        """
        return self.__list[index]

    def __setitem__(self, index, value):  #不允许数据改变，以免破坏有序性
        raise TypeError("use add() to insert a value and rely on "
                        "the list to put it in the right place")

    def __iter__(self):
        """Returns an iterator for the list
        """
        return iter(self.__list)

    def __reversed__(self):
        """Returns a reverse iterator for the list
        """
        return reversed(self.__list)

    def __contains__(self, value):
        """Returns True if value is in the list; otherwise returns False
        """
        key, index = self.__bisect_left(value)
        return (index < len(self.__list) and
                self.__key(self.__list[index]) == key)

    def __len__(self):
        """Returns the length of the list
        """
        return len(self.__list)

    def __str__(self):
        """Returns a human readable string version of the list; the
        """
        return str(self.__list)
    def copy(self):
        """Returns a shallow copy of the list with the same key function
        """
        return SortedList(self, self.__key)
        
    __copy__ = copy  #将深拷贝指向浅拷贝

#SortedDict提供与dict相同的API，键能根据指定的key函数或者identity函数排序
#使用聚集于继承，排序后的键列表具体成一个实例变量

class SortedDict(dict):
    def __init__(self, dictionary=None, key=None, **kwargs):
        """Initializes with a shallow copy of the given dictionary
        and/or with keyword key=value pairs and preserving order using
        the key function. All keys must be unique.

        key is a key function which defaults to the identity function if it is not specified
        使用示例如下
        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> list(d.items())
        [('a', 2), ('i', 4), ('n', 3), ('s', 1), ('t', 5), ('y', 6)]
        >>> dict(SortedDict())
        {}
        >>> e = SortedDict(d)
        >>> list(e.items())
        [('a', 2), ('i', 4), ('n', 3), ('s', 1), ('t', 5), ('y', 6)]
        >>> dict(e)
        {'a': 2, 'i': 4, 's': 1, 't': 5, 'y': 6, 'n': 3}
        >>> f = SortedDict(key=str.lower, S=1, a=2, n=3, I=4, T=5, y=6)
        >>> dict(f)
        {'a': 2, 'I': 4, 'S': 1, 'T': 5, 'y': 6, 'n': 3}
        """
        dictionary = dictionary or {}
        super().__init__(dictionary)   #继承父类的初始化函数
        if kwargs:                     #如果有其他参数，将其添加到字典中
            super().update(kwargs)
        self.__keys = SortedList.SortedList(super().keys(), key)

    def update(self, dictionary=None, **kwargs):
        """将新增数据更新到self中
        """
        if dictionary is None:
            pass
        elif isinstance(dictionary, dict):
            super().update(dictionary)
        else:
            for key, value in dictionary.items():
                super().__setitem__(key, value)
        if kwargs:
            super().update(kwargs)
        self.__keys = SortedList.SortedList(super().keys(),self.__keys.key)

    @classmethod
    def fromkeys(cls, iterable, value=None, key=None):
        """A class method that returns a SortedDict whose keys are
        from the iterable and each of whose values is value
        使用迭代器创建对象
        >>> d = SortedDict()
        >>> e = d.fromkeys("KYLIE", 21)
        >>> list(e.items())
        [('E', 21), ('I', 21), ('K', 21), ('L', 21), ('Y', 21)]
        >>> e = SortedDict.fromkeys("KYLIE", 21)
        >>> list(e.items())
        [('E', 21), ('I', 21), ('K', 21), ('L', 21), ('Y', 21)]
        """
        return cls({k: value for k in iterable}, key)

    def value_at(self, index):
        """Returns the index-th item's value
        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> d.value_at(0)
        2
        >>> d.value_at(5)
        6
        >>> d.value_at(2)
        3
        >>> d.value_at(19)
        Traceback (most recent call last):
        ...
        IndexError: list index out of range
        """
        return self[self.__keys[index]]

    def set_value_at(self, index, value):
        """Sets the index-th item's value to the given value
        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> d.value_at(5)
        6
        >>> d.set_value_at(5, 99)
        >>> d.value_at(5)
        99
        >>> d.set_value_at(19, 42)
        Traceback (most recent call last):
        ...
        IndexError: list index out of range
        """
        self[self.__keys[index]] = value

    def clear(self):
        """Removes every item from this SortedDict
        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> len(d)
        6
        >>> d.clear()
        >>> len(d)
        0
        >>> d["m"] = 3
        >>> d["a"] = 5
        >>> d["z"] = 7
        >>> d["e"] = 9
        >>> list(d.keys())
        ['a', 'e', 'm', 'z']
        """
        super().clear()
        self.__keys.clear()

    def setdefault(self, key, value=None):
        """If key is in the dictionary, returns its value;
        otherwise adds the key with the given value which is also
        returned
        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> d.setdefault("n", 99)
        3
        >>> list(d.values())
        [2, 4, 3, 1, 5, 6]
        >>> d.setdefault("r", -20)
        -20
        >>> list(d.items())[2:]
        [('n', 3), ('r', -20), ('s', 1), ('t', 5), ('y', 6)]
        >>> d.setdefault("@", -11)
        -11
        >>> d.setdefault("z", 99)
        99
        >>> d.setdefault("m", 50)
        50
        >>> list(d.keys())
        ['@', 'a', 'i', 'm', 'n', 'r', 's', 't', 'y', 'z']
        """
        if key not in self:
            self.__keys.add(key)
        return super().setdefault(key, value)

    def pop(self, key, *args):
        """If key is in the dictionary, returns its value and removes it
        from the dictionary. Otherwise returns arg if specified, or
        raises KeyError if there is no arg.

        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> d.pop("n")
        3
        >>> "n" in d
        False
        >>> d.pop("q", 41)
        41
        >>> list(d.keys())
        ['a', 'i', 's', 't', 'y']
        >>> d.pop("a")
        2
        >>> d.pop("t")
        5
        >>> list(d.keys())
        ['i', 's', 'y']
        >>> d.pop("X")
        Traceback (most recent call last):
        ...
        KeyError: 'X'
        >>> d.pop("X", None)
        >>> d.pop("X", 1)
        1
        """
        if key not in self:
            if len(args) == 0:
                raise KeyError(key)
            return args[0]
        self.__keys.remove(key)
        return super().pop(key, args)

    def popitem(self):
        """Returns and removes an arbitrary item from the dictionary

        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> len(d)
        6
        >>> item = d.popitem()
        >>> item = d.popitem()
        >>> item = d.popitem()
        >>> len(d)
        3
        """
        item = super().popitem()
        self.__keys.remove(item[0])
        return item

    def values(self):
        """Returns the dictionary's values in key order

        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> list(d.values())
        [2, 4, 3, 1, 5, 6]
        """
        for key in self.__keys:
            yield self[key]

    def items(self):
        """Returns the dictionary's items in key order

        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> list(d.items())
        [('a', 2), ('i', 4), ('n', 3), ('s', 1), ('t', 5), ('y', 6)]
        """
        for key in self.__keys:
            yield (key, self[key])

    def __iter__(self):
        """Returns an iterator over the dictionary's keys

        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> list(d)
        ['a', 'i', 'n', 's', 't', 'y']
        >>> list(d.keys())
        ['a', 'i', 'n', 's', 't', 'y']
        """
        return iter(self.__keys)

    keys = __iter__

    def __delitem__(self, key):
        """Deletes the item with the given key from the dictionary

        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> del d["s"]
        >>> del d["y"]
        >>> del d["a"]
        >>> list(d.keys())
        ['i', 'n', 't']
        >>> del d["X"]
        Traceback (most recent call last):
        ...
        KeyError: 'X'
        >>> d = SortedDict(dict(a=1, b=2, z=3))
        >>> list(d.keys())
        ['a', 'b', 'z']
        >>> del d["c"]
        Traceback (most recent call last):
        ...
        KeyError: 'c'
        >>> list(d.keys())
        ['a', 'b', 'z']
        """
        try:
            self.__keys.remove(key)
        except ValueError:
            raise KeyError(key)
        return super().__delitem__(key)

    def __setitem__(self, key, value):
        """If key is in the dictionary, sets its value to value;
        otherwise adds the key to the dictionary with the given value
        >>> d = SortedDict(dict(s=1, a=2, n=3, i=4, t=5, y=6))
        >>> d["t"] = -17
        >>> d["z"] = 43
        >>> d["@"] = -11
        >>> x = d["m"] = 22
        >>> x == 22
        True
        >>> d["r"] = 5
        >>> list(d.keys())
        ['@', 'a', 'i', 'm', 'n', 'r', 's', 't', 'y', 'z']
        """
        if key not in self:
            self.__keys.add(key)
        return super().__setitem__(key, value)

    def __repr__(self):
        return object.__repr__(self)

    def __str__(self):
        return ("{" + ", ".join(["{0!r}: {1!r}".format(k, v) for k, v in self.items()]) + "}")

    def copy(self):
        """Returns a shallow copy of the dictionary with the same
        key function

        >>> d = SortedDict(dict(V=1, E=2, I=3, N=4, S=5))
        >>> e = d.copy()
        >>> str(e)
        "{'E': 2, 'I': 3, 'N': 4, 'S': 5, 'V': 1}"
        >>> import copy
        >>> f = copy.copy(d)
        >>> str(f)
        "{'E': 2, 'I': 3, 'N': 4, 'S': 5, 'V': 1}"
        """
        d = SortedDict()
        super(SortedDict, d).update(self)
        d.__keys = self.__keys.copy()
        return d

    __copy__ = copy

#### 第七章  文件处理##########
#文件格式  二进制文件，文本文件，xml文件，文件名也包含在压缩后的数据中，因此大小会有差异
#数据类型： 字符串、整数、浮点数、布尔型数值、日期

#以面向对象的方法创建数据类，私有属性使用两个下划线引导，其他读写属性使用property和setter设置
#数据示例：
# report_id   str  事件id  以字符串形式表示，至少8位
# date        datetime.date  时间
# airport     str   航班编号 字符串，非空无换行
# aircraft_id str   航班编号 字符串，非空无换行
# aircraft_type  str  航班类型  
# pilot_percent_hours_on_type float 范围0.0到100.0
# pilot_total_housr  int  正数非0
# midair   bool  
# narrative   str  多行字符串

class IncidentError(Exception): pass


class Incident:
    def __init__(self, report_id, date, airport, aircraft_id,
                 aircraft_type, pilot_percent_hours_on_type,
                 pilot_total_hours, midair, narrative=""):
        """
        >>> kwargs = dict(report_id="2007061289X")
        >>> kwargs["date"] = datetime.date(2007, 6, 12)
        >>> kwargs["airport"] = "Los Angeles"
        >>> kwargs["aircraft_id"] = "8184XK"
        >>> kwargs["aircraft_type"] = "CVS91"
        >>> kwargs["pilot_percent_hours_on_type"] = 17.5
        >>> kwargs["pilot_total_hours"] = 1258
        >>> kwargs["midair"] = False

        注意这里实例化 incident 的时候，是将一个字典作为参数传递进去
        >>> incident = Incident(**kwargs)
        
        >>> incident.report_id, incident.date, incident.airport
        ('2007061289X', datetime.date(2007, 6, 12), 'Los Angeles')
        >>> incident.aircraft_id, incident.aircraft_type, incident.midair
        ('8184XK', 'CVS91', False)
        >>> incident.pilot_percent_hours_on_type, incident.pilot_total_hours
        (17.5, 1258)
        >>> incident.approximate_hours_on_type
        220
        >>> incident.narrative = "Two different\\nlines of text"
        >>> str(incident)
        "Incident('2007061289X', datetime.date(2007, 6, 12), 'Los Angeles', '8184XK', 'CVS91', 17.5, 1258, False, '''Two different\\nlines of text''')"
        >>> kwargs["report_id"] = "fail"
        >>> incident = Incident(**kwargs)
        Traceback (most recent call last):
        ...
        AssertionError: invalid report ID
        """
        # report_id是只读属性，进行隐藏，使用assert断言来指定范围
        assert len(report_id) >= 8 and len(report_id.split()) == 1, \
               "invalid report ID"
        self.__report_id = report_id
        self.date = date
        self.airport = airport
        self.aircraft_id = aircraft_id
        self.aircraft_type = aircraft_type
        self.pilot_percent_hours_on_type = pilot_percent_hours_on_type
        self.pilot_total_hours = pilot_total_hours
        self.midair = midair
        self.narrative = narrative

    @property
    def report_id(self):
        return self.__report_id

    @property
    def date(self):
        "The incident date"
        return self.__date
    #对属性设置setter时添加断言
    @date.setter
    def date(self, date):
        assert isinstance(date, datetime.date), "invalid date"
        self.__date = date

    @property
    def pilot_percent_hours_on_type(self):
        "The percentage of total hours flown on this aircraft type"
        return self.__pilot_percent_hours_on_type

    @pilot_percent_hours_on_type.setter
    def pilot_percent_hours_on_type(self, percent):
        assert 0.0 <= percent <= 100.0, "out of range percentage"
        self.__pilot_percent_hours_on_type = percent

    @property
    def pilot_total_hours(self):
        "The total hours this pilot has flown"
        return self.__pilot_total_hours

    @pilot_total_hours.setter
    def pilot_total_hours(self, hours):
        assert hours > 0, "invalid number of hours"
        self.__pilot_total_hours = hours

    @property
    def approximate_hours_on_type(self):
        return int(self.__pilot_total_hours *
                   (self.__pilot_percent_hours_on_type / 100))

    @property
    def midair(self):
        "Whether the incident involved another aircraft"
        return self.__midair

    @midair.setter
    def midair(self, value):
        assert isinstance(value, bool), "invalid midair value"
        self.__midair = value

    @property
    def airport(self):
        "The incident's airport"
        return self.__airport

    @airport.setter
    def airport(self, airport):
        assert airport and "\n" not in airport, "invalid airport"
        self.__airport = airport

    @property
    def aircraft_id(self):
        "The aircraft ID"
        return self.__aircraft_id

    @aircraft_id.setter
    def aircraft_id(self, aircraft_id):
        assert aircraft_id and "\n" not in aircraft_id, \
               "invalid aircraft ID"
        self.__aircraft_id = aircraft_id

    @property
    def aircraft_type(self):
        "The aircraft type"
        return self.__aircraft_type

    @aircraft_type.setter
    def aircraft_type(self, aircraft_type):
        assert aircraft_type and "\n" not in aircraft_type, \
               "invalid aircraft type"
        self.__aircraft_type = aircraft_type

    @property
    def narrative(self):
        "The incident's narrative"
        return self.__narrative

    @narrative.setter
    def narrative(self, narrative):
        self.__narrative = narrative


    def __repr__(self):
        return ("Incident({report_id!r}, {date!r}, "
                "{airport!r}, {aircraft_id!r}, "
                "{aircraft_type!r}, "
                "{pilot_percent_hours_on_type!r}, "
                "{pilot_total_hours!r}, {midair!r}, "
                "'''{narrative}''')".format(**self))        

#实现字典类，用于统计incident，其中key是incident的report_id，value是incident的实例
class IncidentCollection(dict):

    """
    使用示例
    >>> incidents = IncidentCollection()
    >>> 创建incident实例，incident = Incident(**kwargs)
    >>> incidents[incident.report_id] = incident
    """
    def values(self):
        for report_id in self.keys():
            yield self[report_id]

    def items(self):
        for report_id in self.keys():
            yield (report_id, self[report_id])

    def __iter__(self):
        for report_id in sorted(super().keys()):
            yield report_id

    keys = __iter__

    def __reversed__(self):
        for report_id in sorted(super().keys(), reverse=True):
            yield report_id
#-------------------pickle 导入导出二进制 ---------------------------
    # pickle 没有安全机制，是二进制保存数据的一种方式，序列化性能比较好
    #以 pickle 方式导出生成 二进制文件
    def export_pickle(self, filename, compress=False):
        fh = None
        try:
            if compress:
                #注意 import pickle,gzip
                fh = gzip.open(filename, "wb")
            else:
                fh = open(filename, "wb")
                #pickle.HIGHEST_PROTOCOL表示protocol 3
            pickle.dump(self, fh, pickle.HIGHEST_PROTOCOL)
            return True
        except (EnvironmentError, pickle.PicklingError) as err:
            print("{0}: export error: {1}".format(
                  os.path.basename(sys.argv[0]), err))
            return False
        finally:
            if fh is not None:
                fh.close()

    # 读取二进制文件时，不知道是否使用gzip压缩过，判断方法是读入前两个字节，判断是否是gzip压缩的
    # 魔数,GZIP_MAGIC = b"\x1F\x8B"，如果是的话，使用 gzip.open重新打开文件
    GZIP_MAGIC = b"\x1F\x8B"
    def import_pickle(self, filename):
        fh = None
        try:
            fh = open(filename, "rb")
            magic = fh.read(len(GZIP_MAGIC))
            if magic == GZIP_MAGIC:
                fh.close()
                fh = gzip.open(filename, "rb")
            else:
                fh.seek(0)  #非gzip压缩时，开头即数据，定位到开头
            self.clear()
            self.update(pickle.load(fh))
            return True
        except (EnvironmentError, pickle.UnpicklingError) as err:
            print("{0}: import error: {1}".format(
                  os.path.basename(sys.argv[0]), err))
            return False
        finally:
            if fh is not None:
                fh.close()

#-------------自定义 二进制 数据导入导出----------------------


```

